name: episode-unit-tests

on:
  pull_request:
    branches:
      - main
  push:
    branches:
      - main

jobs:
  episode-unit-tests:
    name: episode-unit-tests
    runs-on: macos-15
    timeout-minutes: 30
    env:
      PHASE2_MODE: enforce-all
      PHASE2_OVERALL_LOGIC_THRESHOLD: "85.00"
      PHASE2_CHANGED_FILES_THRESHOLD: "80.00"

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Show Xcode Version
        run: xcodebuild -version

      - name: Ensure iOS Simulator Exists
        run: |
          set -euo pipefail
          AVAILABLE_DEVICES="$(xcrun simctl list devices available)"
          if echo "$AVAILABLE_DEVICES" | grep -Eq '^[[:space:]]*iPhone '; then
            echo "iPhone simulator already exists on runner."
            exit 0
          fi

          RUNTIME_ID="$(xcrun simctl list runtimes available | grep -o 'com\.apple\.CoreSimulator\.SimRuntime\.iOS-[0-9-]*' | tail -n 1 || true)"
          if [ -z "$RUNTIME_ID" ]; then
            echo "::error::No available iOS runtime found."
            xcrun simctl list runtimes available
            exit 1
          fi

          DEVICE_INFO="$(xcrun simctl list devicetypes | awk '
            {
              line=$0
              sub(/^[[:space:]]*/, "", line)
              if (line !~ /^iPhone /) next
              if (tolower(line) ~ /unavailable/) next

              id=line
              sub(/^.*\((com\.apple\.CoreSimulator\.SimDeviceType\.[^)]+)\).*$/, "\\1", id)
              if (id !~ /^com\.apple\.CoreSimulator\.SimDeviceType\./) next

              name=line
              sub(/[[:space:]]+\(com\.apple\.CoreSimulator\.SimDeviceType\.[^)]+\).*$/, "", name)

              gen=0
              if (match(name, /iPhone[[:space:]]+[0-9]+/)) {
                token=substr(name, RSTART, RLENGTH)
                sub(/^iPhone[[:space:]]+/, "", token)
                gen=token+0
              }

              if (best_id == "" || gen > best_gen) {
                best_gen=gen
                best_name=name
                best_id=id
              }
            }
            END {
              if (best_id != "") print best_name "|" best_id
            }
          ')"

          DEVICE_NAME="${DEVICE_INFO%%|*}"
          DEVICE_TYPE_ID="${DEVICE_INFO#*|}"

          if [ -z "$DEVICE_TYPE_ID" ]; then
            echo "::error::No iPhone device type found."
            xcrun simctl list devicetypes
            exit 1
          fi

          CREATED_NAME="$DEVICE_NAME"
          UUID="$(xcrun simctl create "$CREATED_NAME" "$DEVICE_TYPE_ID" "$RUNTIME_ID" 2>/dev/null || true)"
          if [ -z "$UUID" ]; then
            CREATED_NAME="CI ${DEVICE_NAME} ${GITHUB_RUN_ID}"
            UUID="$(xcrun simctl create "$CREATED_NAME" "$DEVICE_TYPE_ID" "$RUNTIME_ID")"
          fi

          xcrun simctl boot "$UUID" || true
          echo "CI_SIMULATOR=$CREATED_NAME" >> "$GITHUB_ENV"
          echo "Created iOS simulator: $CREATED_NAME ($UUID)"

      - name: Select iOS Simulator
        run: |
          set -euo pipefail
          if [ -n "${CI_SIMULATOR:-}" ]; then
            echo "Using preselected simulator: $CI_SIMULATOR"
            exit 0
          fi

          AVAILABLE_DEVICES="$(xcrun simctl list devices available)"
          SIM_NAME="$(echo "$AVAILABLE_DEVICES" | sed -nE 's/^[[:space:]]*(iPhone.*)[[:space:]]+\([0-9A-Fa-f-]+\)[[:space:]]+\([^)]*\)$/\1/p' | head -n 1)"

          if [ -z "$SIM_NAME" ]; then
            echo "::error::No iPhone simulator found on runner."
            echo "$AVAILABLE_DEVICES"
            exit 1
          fi

          echo "CI_SIMULATOR=$SIM_NAME" >> "$GITHUB_ENV"
          echo "Using simulator: $SIM_NAME"

      - name: Run EpisodeStockerTests
        run: |
          mkdir -p artifacts
          xcodebuild test \
            -project EpisodeStocker.xcodeproj \
            -scheme EpisodeStocker \
            -destination "platform=iOS Simulator,name=${CI_SIMULATOR},OS=latest" \
            -parallel-testing-enabled NO \
            -maximum-parallel-testing-workers 1 \
            -only-testing:EpisodeStockerTests \
            -enableCodeCoverage YES \
            -resultBundlePath artifacts/episode-unit-tests.xcresult

      - name: Coverage Baseline Gate (Phase 1)
        run: |
          set -euo pipefail

          BASELINE_DOC="docs/unit-test/coverage-baseline.md"
          RESULT_BUNDLE="artifacts/episode-unit-tests.xcresult"
          SUMMARY_FILE="artifacts/coverage-summary.md"

          if [ ! -f "$BASELINE_DOC" ]; then
            echo "::error::Baseline file not found: $BASELINE_DOC"
            exit 1
          fi

          TARGET_REPORT="$(xcrun xccov view --report --only-targets "$RESULT_BUNDLE")"
          FULL_REPORT="$(xcrun xccov view --report "$RESULT_BUNDLE")"

          baseline_value() {
            local metric_id="$1"
            awk -F'|' -v id="$metric_id" '
              $0 ~ "\\|[[:space:]]*" id "[[:space:]]*\\|" {
                value=$4
                gsub(/[[:space:]]/, "", value)
                print value
                exit
              }
            ' "$BASELINE_DOC"
          }

          coverage_for_pattern() {
            local pattern="$1"
            local line
            line="$(echo "$FULL_REPORT" | grep -F "$pattern" | head -n 1 || true)"
            if [ -z "$line" ]; then
              echo ""
              return
            fi
            echo "$line" | sed -E 's/.* ([0-9]+(\.[0-9]+)?)% .*/\1/'
          }

          app_current="$(echo "$TARGET_REPORT" | awk '/EpisodeStocker\.app/{gsub("%","",$4); print $4; exit}')"
          swiftdata_current="$(coverage_for_pattern "ios/Services/SwiftDataPersistence.swift")"
          repo_current="$(coverage_for_pattern "ios/Services/InMemorySuggestionRepository.swift")"
          viewmodel_current="$(coverage_for_pattern "ios/ViewModels/SuggestionManagerViewModel.swift")"
          seed_current="$(coverage_for_pattern "ios/Services/SeedData.swift")"
          router_current="$(coverage_for_pattern "ios/ViewModels/AppRouter.swift")"
          episode_current="$(coverage_for_pattern "ios/Models/Episode.swift")"

          {
            echo "# Coverage Baseline Check (Phase 1)"
            echo ""
            echo "| Metric | Baseline | Current | Gate | Result |"
            echo "|---|---:|---:|---|---|"
          } > "$SUMMARY_FILE"

          failures=0

          check_metric() {
            local metric_id="$1"
            local label="$2"
            local current="$3"
            local gate="$4"
            local baseline
            local result

            baseline="$(baseline_value "$metric_id")"
            if [ -z "$baseline" ]; then
              echo "::error::Baseline not found for metric: $metric_id"
              result="FAIL (baseline missing)"
              failures=$((failures + 1))
              echo "| $label | (missing) | ${current:-n/a} | $gate | $result |" >> "$SUMMARY_FILE"
              return
            fi

            if [ -z "$current" ]; then
              echo "::error::Coverage not found for metric: $label"
              result="FAIL (current missing)"
              failures=$((failures + 1))
              echo "| $label | $baseline | (missing) | $gate | $result |" >> "$SUMMARY_FILE"
              return
            fi

            if [ "$gate" = "yes" ]; then
              if awk -v c="$current" -v b="$baseline" 'BEGIN { exit (c+0 >= b+0 ? 0 : 1) }'; then
                result="PASS"
              else
                echo "::error::Coverage regression: $label current=$current baseline=$baseline"
                result="FAIL (regression)"
                failures=$((failures + 1))
              fi
            else
              result="INFO"
            fi

            echo "| $label | $baseline | $current | $gate | $result |" >> "$SUMMARY_FILE"
          }

          check_metric "app_overall" "EpisodeStocker.app" "$app_current" "no"
          check_metric "file_swiftdata_persistence" "SwiftDataPersistence.swift" "$swiftdata_current" "yes"
          check_metric "file_suggestion_repository" "InMemorySuggestionRepository.swift" "$repo_current" "yes"
          check_metric "file_suggestion_manager_viewmodel" "SuggestionManagerViewModel.swift" "$viewmodel_current" "yes"
          check_metric "file_seed_data" "SeedData.swift" "$seed_current" "yes"
          check_metric "file_app_router" "AppRouter.swift" "$router_current" "yes"
          check_metric "file_episode_model" "Episode.swift" "$episode_current" "yes"

          cat "$SUMMARY_FILE"

          if [ "$failures" -gt 0 ]; then
            echo "::error::Coverage baseline gate failed with $failures issue(s)."
            exit 1
          fi

      - name: Coverage Threshold Gate (Phase 2)
        env:
          BASE_SHA: ${{ github.event.pull_request.base.sha }}
          HEAD_SHA: ${{ github.event.pull_request.head.sha }}
        run: |
          set -euo pipefail

          RESULT_BUNDLE="artifacts/episode-unit-tests.xcresult"
          SUMMARY_FILE="artifacts/coverage-summary.md"
          FULL_REPORT="$(xcrun xccov view --report "$RESULT_BUNDLE")"

          logic_file_line() {
            local repo_file="$1"
            echo "$FULL_REPORT" | grep -F "/$repo_file " | head -n 1 || true
          }

          coverage_percent_for_file() {
            local repo_file="$1"
            local line
            line="$(logic_file_line "$repo_file")"
            if [ -z "$line" ]; then
              echo ""
              return
            fi
            echo "$line" | sed -E 's/.* ([0-9]+(\.[0-9]+)?)% .*/\1/'
          }

          coverage_counts_for_file() {
            local repo_file="$1"
            local line
            line="$(logic_file_line "$repo_file")"
            if [ -z "$line" ]; then
              echo ""
              return
            fi
            echo "$line" | sed -E 's/.*\(([0-9]+)\/([0-9]+)\).*/\1 \2/'
          }

          logic_changed_files() {
            if [ "${GITHUB_EVENT_NAME}" = "pull_request" ] && [ -n "${BASE_SHA:-}" ] && [ -n "${HEAD_SHA:-}" ]; then
              git diff --name-only "${BASE_SHA}...${HEAD_SHA}" || true
            else
              git diff --name-only HEAD~1...HEAD || true
            fi | awk '/^ios\/(Services|ViewModels|Models)\/.*\.swift$/ && $0 !~ /^ios\/Views\//'
          }

          overall_logic_counts() {
            echo "$FULL_REPORT" \
              | awk '/\/ios\/Services\/.*\.swift|\/ios\/ViewModels\/.*\.swift|\/ios\/Models\/.*\.swift/' \
              | sed -nE 's/.*\(([0-9]+)\/([0-9]+)\).*/\1 \2/p' \
              | awk '{ covered += $1; total += $2 } END { printf "%d %d\n", covered, total }'
          }

          OVERALL_COUNTS="$(overall_logic_counts)"
          OVERALL_COVERED="$(echo "$OVERALL_COUNTS" | awk '{print $1}')"
          OVERALL_TOTAL="$(echo "$OVERALL_COUNTS" | awk '{print $2}')"
          if [ "${OVERALL_TOTAL:-0}" -eq 0 ]; then
            OVERALL_PERCENT=""
          else
            OVERALL_PERCENT="$(awk -v c="$OVERALL_COVERED" -v t="$OVERALL_TOTAL" 'BEGIN { printf "%.2f", (100*c)/t }')"
          fi

          CHANGED_FILES="$(logic_changed_files)"
          CHANGED_TOTAL=0
          CHANGED_FAILS=0
          PARSE_FAILS=0

          {
            echo ""
            echo "## Coverage Threshold Check (Phase 2)"
            echo ""
            echo "- mode: ${PHASE2_MODE}"
            echo "- overall logic threshold: ${PHASE2_OVERALL_LOGIC_THRESHOLD}%"
            echo "- changed-files threshold: ${PHASE2_CHANGED_FILES_THRESHOLD}%"
            echo ""
            echo "| Scope | Target | Threshold | Current | Result |"
            echo "|---|---|---:|---:|---|"
          } >> "$SUMMARY_FILE"

          if [ -z "$OVERALL_PERCENT" ]; then
            echo "::error::Unable to compute overall logic coverage."
            PARSE_FAILS=$((PARSE_FAILS + 1))
            echo "| overall-logic | ios/{Services,ViewModels,Models} | ${PHASE2_OVERALL_LOGIC_THRESHOLD} | (missing) | FAIL(parse) |" >> "$SUMMARY_FILE"
          else
            overall_result="PASS"
            if awk -v c="$OVERALL_PERCENT" -v t="$PHASE2_OVERALL_LOGIC_THRESHOLD" 'BEGIN { exit (c+0 >= t+0 ? 0 : 1) }'; then
              overall_result="PASS"
            else
              overall_result="WARN(threshold)"
            fi
            echo "| overall-logic | ios/{Services,ViewModels,Models} | ${PHASE2_OVERALL_LOGIC_THRESHOLD} | ${OVERALL_PERCENT} | ${overall_result} |" >> "$SUMMARY_FILE"
          fi

          if [ -z "$CHANGED_FILES" ]; then
            echo "| changed-files | (none) | ${PHASE2_CHANGED_FILES_THRESHOLD} | n/a | INFO |" >> "$SUMMARY_FILE"
          else
            while IFS= read -r file; do
              [ -z "$file" ] && continue
              CHANGED_TOTAL=$((CHANGED_TOTAL + 1))
              current="$(coverage_percent_for_file "$file")"
              if [ -z "$current" ]; then
                PARSE_FAILS=$((PARSE_FAILS + 1))
                CHANGED_FAILS=$((CHANGED_FAILS + 1))
                echo "::error::Coverage not found for changed logic file: $file"
                echo "| changed-file | $file | ${PHASE2_CHANGED_FILES_THRESHOLD} | (missing) | FAIL(parse) |" >> "$SUMMARY_FILE"
                continue
              fi

              result="PASS"
              if awk -v c="$current" -v t="$PHASE2_CHANGED_FILES_THRESHOLD" 'BEGIN { exit (c+0 >= t+0 ? 0 : 1) }'; then
                result="PASS"
              else
                result="WARN(threshold)"
                CHANGED_FAILS=$((CHANGED_FAILS + 1))
              fi
              echo "| changed-file | $file | ${PHASE2_CHANGED_FILES_THRESHOLD} | ${current} | ${result} |" >> "$SUMMARY_FILE"
            done <<< "$CHANGED_FILES"
          fi

          cat "$SUMMARY_FILE"

          enforce_changed=false
          enforce_overall=false
          case "${PHASE2_MODE}" in
            report-only)
              ;;
            enforce-changed-files)
              enforce_changed=true
              ;;
            enforce-all)
              enforce_changed=true
              enforce_overall=true
              ;;
            *)
              echo "::error::Unknown PHASE2_MODE: ${PHASE2_MODE}"
              exit 1
              ;;
          esac

          failures=0
          enforce_parse=false
          if [ "$enforce_changed" = true ] || [ "$enforce_overall" = true ]; then
            enforce_parse=true
          fi

          if [ "$enforce_parse" = true ] && [ "$PARSE_FAILS" -gt 0 ]; then
            failures=$((failures + PARSE_FAILS))
          fi

          if [ "$enforce_changed" = true ] && [ "$CHANGED_TOTAL" -gt 0 ] && [ "$CHANGED_FAILS" -gt 0 ]; then
            failures=$((failures + CHANGED_FAILS))
          fi

          if [ "$enforce_overall" = true ]; then
            if [ -z "$OVERALL_PERCENT" ]; then
              failures=$((failures + 1))
            elif ! awk -v c="$OVERALL_PERCENT" -v t="$PHASE2_OVERALL_LOGIC_THRESHOLD" 'BEGIN { exit (c+0 >= t+0 ? 0 : 1) }'; then
              failures=$((failures + 1))
            fi
          fi

          if [ "$failures" -gt 0 ]; then
            echo "::error::Phase 2 coverage threshold gate failed (${PHASE2_MODE}), failures=${failures}."
            exit 1
          fi

      - name: Upload xcresult
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: episode-unit-tests-artifacts
          path: artifacts
          if-no-files-found: warn
